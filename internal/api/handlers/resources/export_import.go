package api

import (
	"encoding/csv"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)

// ExportFormat represents the export format
type ExportFormat string

const (
	ExportFormatJSON      ExportFormat = "json"
	ExportFormatCSV       ExportFormat = "csv"
	ExportFormatTerraform ExportFormat = "terraform"
)

// ImportResult represents the result of an import operation
type ImportResult struct {
	Imported int      `json:"imported"`
	Failed   int      `json:"failed"`
	Errors   []string `json:"errors,omitempty"`
}

// handleResourcesExport handles resource export requests
func (s *Server) handleResourcesExport(w http.ResponseWriter, r *http.Request) {
	// Parse request
	var req struct {
		Resources []string `json:"resources,omitempty"`
		Format    string   `json:"format,omitempty"`
	}

	// Try to decode JSON body, otherwise use query params
	json.NewDecoder(r.Body).Decode(&req)

	if req.Format == "" {
		req.Format = r.URL.Query().Get("format")
		if req.Format == "" {
			req.Format = "json"
		}
	}

	// Get resources to export
	var resources []Resource
	if len(req.Resources) > 0 {
		// Export specific resources
		resources = s.discoveryHub.GetResourcesByIDs(req.Resources)
	} else {
		// Export all resources
		resources = s.discoveryHub.GetCachedResources()
	}

	// Export based on format
	switch ExportFormat(req.Format) {
	case ExportFormatCSV:
		s.exportResourcesCSV(w, resources)
	case ExportFormatTerraform:
		s.exportResourcesTerraform(w, resources)
	default:
		s.exportResourcesJSON(w, resources)
	}
}

// exportResourcesJSON exports resources as JSON
func (s *Server) exportResourcesJSON(w http.ResponseWriter, resources []Resource) {
	filename := fmt.Sprintf("resources-export-%s.json", time.Now().Format("20060102-150405"))

	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"", filename))

	export := map[string]interface{}{
		"exported_at": time.Now(),
		"total":       len(resources),
		"resources":   resources,
	}

	json.NewEncoder(w).Encode(export)
}

// exportResourcesCSV exports resources as CSV
func (s *Server) exportResourcesCSV(w http.ResponseWriter, resources []Resource) {
	filename := fmt.Sprintf("resources-export-%s.csv", time.Now().Format("20060102-150405"))

	w.Header().Set("Content-Type", "text/csv")
	w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"", filename))

	writer := csv.NewWriter(w)
	defer writer.Flush()

	// Write header
	header := []string{"ID", "Name", "Type", "Provider", "Region", "Status", "Created", "Tags"}
	writer.Write(header)

	// Write resources
	for _, resource := range resources {
		tags := []string{}
		for k, v := range resource.Tags {
			tags = append(tags, fmt.Sprintf("%s=%s", k, v))
		}

		row := []string{
			resource.ID,
			resource.Name,
			resource.Type,
			resource.Provider,
			resource.Region,
			resource.Status,
			resource.CreatedAt,
			strings.Join(tags, ";"),
		}
		writer.Write(row)
	}
}

// exportResourcesTerraform exports resources as Terraform configuration
func (s *Server) exportResourcesTerraform(w http.ResponseWriter, resources []Resource) {
	filename := fmt.Sprintf("resources-export-%s.tf", time.Now().Format("20060102-150405"))

	w.Header().Set("Content-Type", "text/plain")
	w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"", filename))

	// Group resources by provider
	byProvider := make(map[string][]Resource)
	for _, resource := range resources {
		byProvider[resource.Provider] = append(byProvider[resource.Provider], resource)
	}

	// Generate Terraform configuration
	fmt.Fprintf(w, "# Generated by DriftMgr on %s\n\n", time.Now().Format(time.RFC3339))

	for provider, providerResources := range byProvider {
		fmt.Fprintf(w, "# Provider: %s\n", provider)
		fmt.Fprintf(w, "provider \"%s\" {\n", provider)
		if provider == "aws" {
			fmt.Fprintf(w, "  # Configure AWS provider\n")
			fmt.Fprintf(w, "  region = \"us-east-1\"\n")
		}
		fmt.Fprintf(w, "}\n\n")

		// Generate import commands
		fmt.Fprintf(w, "# Import commands for %s resources\n", provider)
		for _, resource := range providerResources {
			resourceType := s.mapToTerraformResourceType(resource.Type, provider)
			resourceName := s.sanitizeResourceName(resource.Name)

			fmt.Fprintf(w, "# terraform import %s.%s %s\n", resourceType, resourceName, resource.ID)

			// Export resource configuration
			fmt.Fprintf(w, "  # Resource Configuration\n")
			fmt.Fprintf(w, "  resource \"%s\" \"%s\" {\n", resource.Type, resource.Name)

			// Export basic properties
			if resource.Properties != nil {
				for key, value := range resource.Properties {
					if key != "id" && key != "arn" && key != "name" {
						switch v := value.(type) {
						case string:
							fmt.Fprintf(w, "    %s = \"%s\"\n", key, v)
						case int, int64:
							fmt.Fprintf(w, "    %s = %d\n", key, v)
						case bool:
							fmt.Fprintf(w, "    %s = %t\n", key, v)
						case []interface{}:
							if len(v) > 0 {
								fmt.Fprintf(w, "    %s = [\n", key)
								for _, item := range v {
									fmt.Fprintf(w, "      \"%v\",\n", item)
								}
								fmt.Fprintf(w, "    ]\n")
							}
						case map[string]interface{}:
							if len(v) > 0 {
								fmt.Fprintf(w, "    %s = {\n", key)
								for k, val := range v {
									fmt.Fprintf(w, "      %s = \"%v\"\n", k, val)
								}
								fmt.Fprintf(w, "    }\n")
							}
						default:
							fmt.Fprintf(w, "    %s = \"%v\"\n", key, v)
						}
					}
				}
			}

			// Export tags if present
			if resource.Tags != nil && len(resource.Tags) > 0 {
				fmt.Fprintf(w, "    tags = {\n")
				for key, value := range resource.Tags {
					fmt.Fprintf(w, "      %s = \"%s\"\n", key, value)
				}
				fmt.Fprintf(w, "    }\n")
			}

			fmt.Fprintf(w, "  }\n\n")
		}
	}
}

// handleResourcesImport handles resource import requests
func (s *Server) handleResourcesImport(w http.ResponseWriter, r *http.Request) {
	// Parse multipart form
	err := r.ParseMultipartForm(10 << 20) // 10 MB max
	if err != nil {
		sendJSONError(w, "Failed to parse upload", http.StatusBadRequest)
		return
	}

	file, header, err := r.FormFile("file")
	if err != nil {
		sendJSONError(w, "No file provided", http.StatusBadRequest)
		return
	}
	defer file.Close()

	// Determine file format
	format := "json"
	if strings.HasSuffix(header.Filename, ".csv") {
		format = "csv"
	} else if strings.HasSuffix(header.Filename, ".tf") {
		format = "terraform"
	}

	// Import based on format
	var result ImportResult
	switch format {
	case "csv":
		result = s.importResourcesCSV(file)
	case "terraform":
		result = s.importResourcesTerraform(file)
	default:
		result = s.importResourcesJSON(file)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(result)
}

// importResourcesJSON imports resources from JSON
func (s *Server) importResourcesJSON(file io.Reader) ImportResult {
	result := ImportResult{
		Errors: []string{},
	}

	var data struct {
		Resources []Resource `json:"resources"`
	}

	if err := json.NewDecoder(file).Decode(&data); err != nil {
		result.Errors = append(result.Errors, fmt.Sprintf("Failed to parse JSON: %v", err))
		return result
	}

	// Import resources
	for _, resource := range data.Resources {
		if err := s.validateResource(resource); err != nil {
			result.Failed++
			result.Errors = append(result.Errors, fmt.Sprintf("Resource %s: %v", resource.ID, err))
			continue
		}

		// Add to discovery hub cache
		s.discoveryHub.AddResource(resource)
		result.Imported++
	}

	return result
}

// importResourcesCSV imports resources from CSV
func (s *Server) importResourcesCSV(file io.Reader) ImportResult {
	result := ImportResult{
		Errors: []string{},
	}

	reader := csv.NewReader(file)

	// Read header
	header, err := reader.Read()
	if err != nil {
		result.Errors = append(result.Errors, fmt.Sprintf("Failed to read CSV header: %v", err))
		return result
	}

	// Map header indices
	indices := make(map[string]int)
	for i, col := range header {
		indices[col] = i
	}

	// Read records
	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			result.Failed++
			result.Errors = append(result.Errors, fmt.Sprintf("CSV read error: %v", err))
			continue
		}

		// Create resource from CSV record
		resource := Resource{
			ID:       s.getCSVField(record, indices, "ID"),
			Name:     s.getCSVField(record, indices, "Name"),
			Type:     s.getCSVField(record, indices, "Type"),
			Provider: s.getCSVField(record, indices, "Provider"),
			Region:   s.getCSVField(record, indices, "Region"),
			Status:   s.getCSVField(record, indices, "Status"),
			Tags:     make(map[string]string),
		}

		// Parse tags
		if tagsStr := s.getCSVField(record, indices, "Tags"); tagsStr != "" {
			for _, tag := range strings.Split(tagsStr, ";") {
				parts := strings.SplitN(tag, "=", 2)
				if len(parts) == 2 {
					resource.Tags[parts[0]] = parts[1]
				}
			}
		}

		if err := s.validateResource(resource); err != nil {
			result.Failed++
			result.Errors = append(result.Errors, fmt.Sprintf("Resource %s: %v", resource.ID, err))
			continue
		}

		s.discoveryHub.AddResource(resource)
		result.Imported++
	}

	return result
}

// importResourcesTerraform imports resources from Terraform configuration
func (s *Server) importResourcesTerraform(file io.Reader) ImportResult {
	result := ImportResult{
		Errors: []string{},
	}

	// This is a simplified implementation
	// In production, you would use HCL parser
	result.Errors = append(result.Errors, "Terraform import not fully implemented yet")

	return result
}

// validateResource validates a resource before import
func (s *Server) validateResource(resource Resource) error {
	if resource.ID == "" {
		return fmt.Errorf("resource ID is required")
	}
	if resource.Type == "" {
		return fmt.Errorf("resource type is required")
	}
	if resource.Provider == "" {
		return fmt.Errorf("resource provider is required")
	}
	return nil
}

// getCSVField safely gets a field from CSV record
func (s *Server) getCSVField(record []string, indices map[string]int, field string) string {
	if idx, ok := indices[field]; ok && idx < len(record) {
		return record[idx]
	}
	return ""
}

// mapToTerraformResourceType maps internal resource type to Terraform resource type
func (s *Server) mapToTerraformResourceType(resourceType, provider string) string {
	// This is a simplified mapping
	switch provider {
	case "aws":
		if strings.Contains(resourceType, "Instance") {
			return "aws_instance"
		}
		if strings.Contains(resourceType, "Bucket") {
			return "aws_s3_bucket"
		}
		if strings.Contains(resourceType, "Database") {
			return "aws_db_instance"
		}
	case "azure":
		if strings.Contains(resourceType, "VirtualMachine") {
			return "azurerm_virtual_machine"
		}
	case "gcp":
		if strings.Contains(resourceType, "Instance") {
			return "google_compute_instance"
		}
	}

	return fmt.Sprintf("%s_%s", provider, strings.ToLower(resourceType))
}

// sanitizeResourceName sanitizes resource name for Terraform
func (s *Server) sanitizeResourceName(name string) string {
	// Replace non-alphanumeric characters with underscores
	result := strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '_' {
			return r
		}
		return '_'
	}, name)

	// Ensure it starts with a letter
	if len(result) > 0 && result[0] >= '0' && result[0] <= '9' {
		result = "resource_" + result
	}

	return result
}
