# GitLab CI/CD Pipeline for DriftMgr
# Infrastructure Drift Detection and Management Tool

stages:
  - validate
  - test
  - build
  - security
  - drift-detection
  - release
  - deploy

variables:
  GO_VERSION: "1.23.8"
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""
  REGISTRY: $CI_REGISTRY
  IMAGE_NAME: $CI_PROJECT_PATH
  KUBECONFIG: /tmp/kubeconfig

# Global configuration
default:
  image: golang:${GO_VERSION}
  before_script:
    - apt-get update -qq && apt-get install -y -qq git curl jq
    - mkdir -p $GOPATH/src/$(dirname $REPO_NAME)
    - ln -svf $CI_PROJECT_DIR $GOPATH/src/$REPO_NAME
    - cd $GOPATH/src/$REPO_NAME

# Cache configuration
.go-cache: &go-cache
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - /go/pkg/mod/
      - .cache/

# Validation Stage
validate:syntax:
  stage: validate
  <<: *go-cache
  script:
    - go fmt -l . | tee /tmp/fmt-check
    - test ! -s /tmp/fmt-check || (echo "Code not formatted properly" && exit 1)
    - go vet ./...
    - go mod verify
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

validate:dependencies:
  stage: validate
  <<: *go-cache
  script:
    - go mod download
    - go mod tidy
    - git diff --exit-code go.mod go.sum || (echo "go.mod/go.sum not up to date" && exit 1)
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Test Stage
test:unit:
  stage: test
  <<: *go-cache
  script:
    - go test -v -race -coverprofile=coverage.out ./...
    - go tool cover -html=coverage.out -o coverage.html
    - go tool cover -func=coverage.out | grep total | awk '{print $3}' | tee coverage.txt
  coverage: '/total.*?(\d+.\d+%)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - coverage.html
      - coverage.out
    expire_in: 30 days
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

test:integration:
  stage: test
  <<: *go-cache
  services:
    - postgres:15
    - redis:7
  variables:
    POSTGRES_DB: driftmgr_test
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_HOST_AUTH_METHOD: trust
    DATABASE_URL: postgres://postgres:postgres@postgres:5432/driftmgr_test?sslmode=disable
    REDIS_URL: redis://redis:6379
  script:
    - go test -v -tags=integration ./tests/integration/...
  artifacts:
    reports:
      junit: integration-test-report.xml
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - "**/*.go"
        - "go.mod"
        - "go.sum"

test:benchmark:
  stage: test
  <<: *go-cache
  script:
    - go test -bench=. -benchmem ./... | tee benchmark.txt
  artifacts:
    paths:
      - benchmark.txt
    expire_in: 7 days
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - when: manual

# Build Stage
build:binaries:
  stage: build
  <<: *go-cache
  parallel:
    matrix:
      - GOOS: [linux, windows, darwin]
        GOARCH: [amd64, arm64]
  script:
    - |
      if [ "$GOOS" = "windows" ]; then
        SUFFIX=".exe"
      else
        SUFFIX=""
      fi
    - export CGO_ENABLED=0
    - mkdir -p dist
    - |
      LDFLAGS="-s -w -X main.version=${CI_COMMIT_TAG:-$CI_COMMIT_SHORT_SHA} -X main.commit=$CI_COMMIT_SHA -X main.date=$(date -u '+%Y-%m-%d_%H:%M:%S')"
    - go build -ldflags="$LDFLAGS" -o dist/driftmgr-$GOOS-$GOARCH$SUFFIX ./cmd/driftmgr
    - go build -ldflags="$LDFLAGS" -o dist/driftmgr-server-$GOOS-$GOARCH$SUFFIX ./cmd/server
    - go build -ldflags="$LDFLAGS" -o dist/validate-discovery-$GOOS-$GOARCH$SUFFIX ./cmd/validate
    - |
      cd dist
      if [ "$GOOS" = "windows" ]; then
        zip -r driftmgr-$GOOS-$GOARCH.zip *$GOOS-$GOARCH*
      else
        tar -czf driftmgr-$GOOS-$GOARCH.tar.gz *$GOOS-$GOARCH*
      fi
  artifacts:
    paths:
      - dist/
    expire_in: 7 days
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

build:docker:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  variables:
    DOCKER_BUILDKIT: 1
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - |
      if [ "$CI_COMMIT_TAG" ]; then
        TAG="$CI_COMMIT_TAG"
        docker build --build-arg VERSION=$CI_COMMIT_TAG -t $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG .
        docker build --build-arg VERSION=$CI_COMMIT_TAG -t $CI_REGISTRY_IMAGE:latest .
        docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG
        docker push $CI_REGISTRY_IMAGE:latest
      else
        TAG="$CI_COMMIT_SHORT_SHA"
        docker build --build-arg VERSION=$CI_COMMIT_SHORT_SHA -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA .
        docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
      fi
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Security Stage
security:sast:
  stage: security
  image: securecodewarrior/gitlab-sast-go:latest
  script:
    - gosec -fmt sarif -out gosec-report.sarif ./...
  artifacts:
    reports:
      sast: gosec-report.sarif
    paths:
      - gosec-report.sarif
    expire_in: 7 days
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

security:dependency-scan:
  stage: security
  <<: *go-cache
  script:
    - go install golang.org/x/vuln/cmd/govulncheck@latest
    - govulncheck ./... | tee vuln-report.txt
    - |
      if grep -q "No vulnerabilities found" vuln-report.txt; then
        echo "No vulnerabilities detected"
      else
        echo "Vulnerabilities found!"
        exit 1
      fi
  artifacts:
    paths:
      - vuln-report.txt
    expire_in: 7 days
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

security:container-scan:
  stage: security
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    - |
      docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
        -v $(pwd):/tmp/trivy aquasec/trivy:latest \
        image --format sarif --output /tmp/trivy/container-scan.sarif \
        $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
  artifacts:
    reports:
      container_scanning: container-scan.sarif
    paths:
      - container-scan.sarif
    expire_in: 7 days
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Drift Detection Stage
drift-detection:scan:
  stage: drift-detection
  <<: *go-cache
  variables:
    AWS_DEFAULT_REGION: us-east-1
  before_script:
    - apt-get update && apt-get install -y curl jq unzip
    # Install AWS CLI
    - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
    - unzip awscliv2.zip && ./aws/install
    # Install Azure CLI
    - curl -sL https://aka.ms/InstallAzureCLIDeb | bash
    # Install GCP CLI
    - echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | tee -a /etc/apt/sources.list.d/google-cloud-sdk.list
    - curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key --keyring /usr/share/keyrings/cloud.google.gpg add -
    - apt-get update && apt-get install -y google-cloud-cli
  script:
    - go build -o driftmgr ./cmd/driftmgr
    - chmod +x driftmgr
    # Configure cloud credentials
    - |
      if [ -n "$AWS_ACCESS_KEY_ID" ]; then
        aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
        aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
        aws configure set default.region $AWS_DEFAULT_REGION
      fi
    - |
      if [ -n "$AZURE_CREDENTIALS" ]; then
        echo "$AZURE_CREDENTIALS" | az login --service-principal -u $AZURE_CLIENT_ID -p $AZURE_CLIENT_SECRET --tenant $AZURE_TENANT_ID
      fi
    - |
      if [ -n "$GCP_SERVICE_ACCOUNT_KEY" ]; then
        echo "$GCP_SERVICE_ACCOUNT_KEY" > gcp-key.json
        gcloud auth activate-service-account --key-file=gcp-key.json
      fi
    # Run drift detection
    - mkdir -p drift-reports
    - |
      ./driftmgr drift detect \
        --provider all \
        --environment ${CI_ENVIRONMENT_NAME:-staging} \
        --output-format json \
        --output-file drift-reports/drift-report-${CI_ENVIRONMENT_NAME:-staging}.json \
        --verbose || true
    # Generate reports
    - |
      if [ -f "drift-reports/drift-report-${CI_ENVIRONMENT_NAME:-staging}.json" ]; then
        DRIFT_COUNT=$(jq '.summary.total_drift_resources // 0' drift-reports/drift-report-${CI_ENVIRONMENT_NAME:-staging}.json)
        echo "Drift detected: $DRIFT_COUNT resources"
        
        if [ "$DRIFT_COUNT" -gt 0 ]; then
          echo "DRIFT_DETECTED=true" >> drift.env
          # Generate HTML report
          ./driftmgr drift analyze \
            --input drift-reports/drift-report-${CI_ENVIRONMENT_NAME:-staging}.json \
            --output drift-reports/analysis-${CI_ENVIRONMENT_NAME:-staging}.html \
            --format html || true
        else
          echo "DRIFT_DETECTED=false" >> drift.env
        fi
      fi
  artifacts:
    paths:
      - drift-reports/
    reports:
      dotenv: drift.env
    expire_in: 30 days
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - when: manual

# Release Stage
release:gitlab:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - build:binaries
    - build:docker
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      # Generate changelog
      echo "## Release $CI_COMMIT_TAG" > CHANGELOG.md
      echo "" >> CHANGELOG.md
      echo "### Changes" >> CHANGELOG.md
      git log --pretty=format:"- %s (%h)" $CI_COMMIT_BEFORE_SHA..$CI_COMMIT_SHA >> CHANGELOG.md || echo "- Initial release" >> CHANGELOG.md
      echo "" >> CHANGELOG.md
      echo "### Docker Images" >> CHANGELOG.md
      echo "- \`$CI_REGISTRY_IMAGE:$CI_COMMIT_TAG\`" >> CHANGELOG.md
      echo "- \`$CI_REGISTRY_IMAGE:latest\`" >> CHANGELOG.md
    - |
      # Create release with assets
      release-cli create \
        --name "Release $CI_COMMIT_TAG" \
        --tag-name $CI_COMMIT_TAG \
        --description "$(cat CHANGELOG.md)" \
        --assets-link "{\"name\":\"Linux AMD64\",\"url\":\"${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/file/dist/driftmgr-linux-amd64.tar.gz\"}" \
        --assets-link "{\"name\":\"Windows AMD64\",\"url\":\"${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/file/dist/driftmgr-windows-amd64.zip\"}" \
        --assets-link "{\"name\":\"macOS AMD64\",\"url\":\"${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/file/dist/driftmgr-darwin-amd64.tar.gz\"}" \
        --assets-link "{\"name\":\"Docker Image\",\"url\":\"$CI_REGISTRY_IMAGE:$CI_COMMIT_TAG\"}"
  rules:
    - if: $CI_COMMIT_TAG

# Deploy Stage
deploy:staging:
  stage: deploy
  image: bitnami/kubectl:latest
  environment:
    name: staging
    url: https://staging.driftmgr.example.com
  before_script:
    - echo "$KUBECONFIG_STAGING" | base64 -d > $KUBECONFIG
  script:
    - kubectl set image deployment/driftmgr driftmgr=$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA -n staging
    - kubectl rollout status deployment/driftmgr -n staging --timeout=300s
    - kubectl get pods -n staging
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

deploy:production:
  stage: deploy
  image: bitnami/kubectl:latest
  environment:
    name: production
    url: https://driftmgr.example.com
  before_script:
    - echo "$KUBECONFIG_PRODUCTION" | base64 -d > $KUBECONFIG
  script:
    - kubectl set image deployment/driftmgr driftmgr=$CI_REGISTRY_IMAGE:$CI_COMMIT_TAG -n production
    - kubectl rollout status deployment/driftmgr -n production --timeout=300s
    - kubectl get pods -n production
  rules:
    - if: $CI_COMMIT_TAG
  when: manual

# Notification Jobs
notify:slack:
  stage: .post
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      if [ "$CI_JOB_STATUS" = "success" ]; then
        COLOR="good"
        EMOJI="[OK]"
      else
        COLOR="danger"
        EMOJI="[ERROR]"
      fi
      
      if [ -n "$SLACK_WEBHOOK_URL" ]; then
        curl -X POST "$SLACK_WEBHOOK_URL" \
          -H 'Content-Type: application/json' \
          -d "{
            \"attachments\": [{
              \"color\": \"$COLOR\",
              \"title\": \"$EMOJI DriftMgr CI/CD Pipeline\",
              \"text\": \"Pipeline $CI_JOB_STATUS for commit $CI_COMMIT_SHORT_SHA\",
              \"fields\": [
                {\"title\": \"Project\", \"value\": \"$CI_PROJECT_NAME\", \"short\": true},
                {\"title\": \"Branch\", \"value\": \"$CI_COMMIT_REF_NAME\", \"short\": true},
                {\"title\": \"Commit\", \"value\": \"$CI_COMMIT_SHORT_SHA\", \"short\": true},
                {\"title\": \"Pipeline\", \"value\": \"[View Pipeline]($CI_PIPELINE_URL)\", \"short\": true}
              ]
            }]
          }"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: always
    - if: $CI_COMMIT_TAG
      when: always

notify:drift-alert:
  stage: .post
  image: alpine:latest
  needs:
    - drift-detection:scan
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      if [ "$DRIFT_DETECTED" = "true" ] && [ -n "$SLACK_WEBHOOK_URL" ]; then
        curl -X POST "$SLACK_WEBHOOK_URL" \
          -H 'Content-Type: application/json' \
          -d "{
            \"attachments\": [{
              \"color\": \"warning\",
              \"title\": \"[WARNING] Infrastructure Drift Detected\",
              \"text\": \"Drift has been detected in the ${CI_ENVIRONMENT_NAME:-staging} environment\",
              \"fields\": [
                {\"title\": \"Environment\", \"value\": \"${CI_ENVIRONMENT_NAME:-staging}\", \"short\": true},
                {\"title\": \"Project\", \"value\": \"$CI_PROJECT_NAME\", \"short\": true},
                {\"title\": \"Pipeline\", \"value\": \"[View Details]($CI_PIPELINE_URL)\", \"short\": false}
              ]
            }]
          }"
      fi
  rules:
    - if: $DRIFT_DETECTED == "true"