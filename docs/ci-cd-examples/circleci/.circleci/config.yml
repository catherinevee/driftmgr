# CircleCI Configuration for DriftMgr
# Infrastructure Drift Detection and Management Tool

version: 2.1

# Orbs provide pre-built functionality
orbs:
  go: circleci/go@1.8.0
  docker: circleci/docker@2.2.0
  aws-cli: circleci/aws-cli@3.1.0
  azure-cli: circleci/azure-cli@1.2.0
  gcp-cli: circleci/gcp-cli@3.1.0
  slack: circleci/slack@4.12.0
  codecov: codecov/codecov@3.2.0

# Custom commands for reusability
commands:
  setup_environment:
    description: "Setup build environment with required tools"
    steps:
      - run:
          name: Install system dependencies
          command: |
            sudo apt-get update -qq
            sudo apt-get install -y jq curl unzip
      
      - run:
          name: Install cloud CLI tools
          command: |
            # AWS CLI (via orb)
            # Azure CLI (via orb)
            # GCP CLI (via orb)
            
            # Install doctl for DigitalOcean
            wget -q https://github.com/digitalocean/doctl/releases/download/v1.94.0/doctl-1.94.0-linux-amd64.tar.gz
            tar xf doctl-1.94.0-linux-amd64.tar.gz
            sudo mv doctl /usr/local/bin/
      
      - run:
          name: Install security tools
          command: |
            # Install gosec
            go install github.com/securecodewarrior/gosec/v2/cmd/gosec@latest
            
            # Install govulncheck
            go install golang.org/x/vuln/cmd/govulncheck@latest
            
            # Install Trivy
            wget -q https://github.com/aquasecurity/trivy/releases/download/v0.45.0/trivy_0.45.0_Linux-64bit.tar.gz
            tar zxf trivy_0.45.0_Linux-64bit.tar.gz
            sudo mv trivy /usr/local/bin/

  configure_cloud_providers:
    description: "Configure cloud provider authentication"
    steps:
      - aws-cli/setup:
          profile-name: default
      - azure-cli/login-with-service-principal
      - gcp-cli/setup
      - run:
          name: Configure DigitalOcean
          command: |
            if [ -n "$DO_TOKEN" ]; then
              doctl auth init --access-token $DO_TOKEN
            fi

  build_driftmgr:
    description: "Build DriftMgr binary"
    steps:
      - run:
          name: Build DriftMgr
          command: |
            go build -o driftmgr ./cmd/driftmgr
            chmod +x driftmgr
            ./driftmgr --version

  run_drift_detection:
    description: "Execute drift detection"
    parameters:
      environment:
        type: string
        default: "staging"
      provider:
        type: string
        default: "all"
      force_scan:
        type: boolean
        default: false
    steps:
      - run:
          name: Run Drift Detection
          command: |
            # Set scan flags
            SCAN_FLAGS=""
            if [ "<< parameters.force_scan >>" = "true" ]; then
              SCAN_FLAGS="--full-scan"
            fi
            
            # Create reports directory
            mkdir -p reports
            
            # Run drift detection
            ./driftmgr drift detect \
              --provider << parameters.provider >> \
              --environment << parameters.environment >> \
              --output-format json \
              --output-file reports/drift-report.json \
              $SCAN_FLAGS \
              --verbose
            
            # Parse results
            if [ -f "reports/drift-report.json" ]; then
              DRIFT_COUNT=$(jq '.summary.total_drift_resources // 0' reports/drift-report.json)
              COST_IMPACT=$(jq '.cost_analysis.total_impact // 0' reports/drift-report.json)
              
              echo "export DRIFT_COUNT=$DRIFT_COUNT" >> $BASH_ENV
              echo "export COST_IMPACT=$COST_IMPACT" >> $BASH_ENV
              
              if [ "$DRIFT_COUNT" -gt 0 ]; then
                echo "export DRIFT_DETECTED=true" >> $BASH_ENV
                echo "[WARNING] Drift detected: $DRIFT_COUNT resources"
              else
                echo "export DRIFT_DETECTED=false" >> $BASH_ENV
                echo "[OK] No drift detected"
              fi
            fi

# Job definitions
jobs:
  # Setup and validation
  setup:
    docker:
      - image: cimg/go:1.23
    steps:
      - checkout
      - setup_environment
      - run:
          name: Verify environment
          command: |
            echo "===========================================" 
            echo "CircleCI Pipeline for DriftMgr"
            echo "==========================================="
            echo "Build Number: $CIRCLE_BUILD_NUM"
            echo "Git SHA: $CIRCLE_SHA1"
            echo "Branch: $CIRCLE_BRANCH"
            echo "Tag: $CIRCLE_TAG"
            echo "==========================================="
            
            go version
            aws --version
            az --version
            gcloud --version
            doctl version

  # Code quality and security
  lint_and_format:
    docker:
      - image: cimg/go:1.23
    steps:
      - checkout
      - go/load-cache
      - go/mod-download
      - run:
          name: Format check
          command: |
            go fmt -l . | tee format-issues.txt
            if [ -s format-issues.txt ]; then
              echo "Code formatting issues found:"
              cat format-issues.txt
              exit 1
            fi
      - run:
          name: Vet check
          command: go vet ./...
      - run:
          name: Module verification
          command: go mod verify
      - go/save-cache

  security_scan:
    docker:
      - image: cimg/go:1.23
    steps:
      - checkout
      - go/load-cache
      - setup_environment
      - run:
          name: Security scan with gosec
          command: |
            mkdir -p reports
            $(go env GOPATH)/bin/gosec -fmt sarif -out reports/gosec-report.sarif ./...
            $(go env GOPATH)/bin/gosec -fmt json -out reports/gosec-report.json ./...
      - run:
          name: Vulnerability check
          command: |
            $(go env GOPATH)/bin/govulncheck ./... | tee reports/vulncheck-report.txt
      - store_artifacts:
          path: reports
          destination: security-reports

  license_check:
    docker:
      - image: cimg/go:1.23
    steps:
      - checkout
      - go/load-cache
      - run:
          name: License compliance check
          command: |
            # Install go-licenses
            go install github.com/google/go-licenses@latest
            
            # Generate license report
            mkdir -p reports
            $(go env GOPATH)/bin/go-licenses report ./... > reports/licenses.txt || true
            
            # Check for forbidden licenses
            if grep -E "(GPL-2|GPL-3|AGPL|LGPL)" reports/licenses.txt; then
              echo "Forbidden licenses detected!"
              exit 1
            fi
      - store_artifacts:
          path: reports/licenses.txt
          destination: license-report

  # Testing
  unit_tests:
    docker:
      - image: cimg/go:1.23
    steps:
      - checkout
      - go/load-cache
      - go/mod-download
      - run:
          name: Run unit tests
          command: |
            mkdir -p reports
            go test -v -race -coverprofile=reports/coverage.out ./... | tee reports/test-results.txt
            
            # Generate coverage report
            go tool cover -html=reports/coverage.out -o reports/coverage.html
            go tool cover -func=reports/coverage.out | grep total | awk '{print $3}' > reports/coverage.txt
            
            # Convert to JUnit format
            go install github.com/jstemmer/go-junit-report/v2@latest
            cat reports/test-results.txt | $(go env GOPATH)/bin/go-junit-report > reports/junit.xml
      - store_test_results:
          path: reports
      - store_artifacts:
          path: reports
          destination: test-reports
      - codecov/upload:
          file: reports/coverage.out
      - go/save-cache

  integration_tests:
    docker:
      - image: cimg/go:1.23
      - image: postgres:15
        environment:
          POSTGRES_DB: driftmgr_test
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
      - image: redis:7
    environment:
      DATABASE_URL: postgres://postgres:postgres@localhost:5432/driftmgr_test?sslmode=disable
      REDIS_URL: redis://localhost:6379
    steps:
      - checkout
      - go/load-cache
      - go/mod-download
      - run:
          name: Wait for database
          command: dockerize -wait tcp://localhost:5432 -timeout 1m
      - run:
          name: Run integration tests
          command: |
            mkdir -p reports
            go test -v -tags=integration ./tests/integration/... | tee reports/integration-test-results.txt
      - store_artifacts:
          path: reports
          destination: integration-test-reports

  benchmark_tests:
    docker:
      - image: cimg/go:1.23
    steps:
      - checkout
      - go/load-cache
      - go/mod-download
      - run:
          name: Run benchmark tests
          command: |
            mkdir -p reports
            go test -bench=. -benchmem ./... | tee reports/benchmark-results.txt
      - store_artifacts:
          path: reports/benchmark-results.txt
          destination: benchmark-results

  # Build artifacts
  build_binaries:
    docker:
      - image: cimg/go:1.23
    parameters:
      goos:
        type: string
      goarch:
        type: string
    steps:
      - checkout
      - go/load-cache
      - run:
          name: Build binaries for << parameters.goos >>-<< parameters.goarch >>
          command: |
            # Set variables
            GOOS=<< parameters.goos >>
            GOARCH=<< parameters.goarch >>
            
            if [ "$GOOS" = "windows" ]; then
              SUFFIX=".exe"
            else
              SUFFIX=""
            fi
            
            LDFLAGS="-s -w -X main.version=$CIRCLE_BUILD_NUM -X main.commit=$CIRCLE_SHA1 -X main.date=$(date -u '+%Y-%m-%d_%H:%M:%S')"
            
            # Build binaries
            mkdir -p artifacts/binaries
            export CGO_ENABLED=0
            export GOOS=$GOOS
            export GOARCH=$GOARCH
            
            go build -ldflags="$LDFLAGS" -o artifacts/binaries/driftmgr-$GOOS-$GOARCH$SUFFIX ./cmd/driftmgr
            go build -ldflags="$LDFLAGS" -o artifacts/binaries/driftmgr-server-$GOOS-$GOARCH$SUFFIX ./cmd/server
            go build -ldflags="$LDFLAGS" -o artifacts/binaries/validate-discovery-$GOOS-$GOARCH$SUFFIX ./cmd/validate
            
            # Create archive
            cd artifacts/binaries
            if [ "$GOOS" = "windows" ]; then
              zip -r driftmgr-$GOOS-$GOARCH.zip *$GOOS-$GOARCH*
            else
              tar -czf driftmgr-$GOOS-$GOARCH.tar.gz *$GOOS-$GOARCH*
            fi
      - store_artifacts:
          path: artifacts/binaries
          destination: binaries-<< parameters.goos >>-<< parameters.goarch >>
      - persist_to_workspace:
          root: artifacts
          paths:
            - binaries/*

  build_docker:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout
      - setup_remote_docker:
          docker_layer_caching: true
      - docker/check
      - run:
          name: Build Docker image
          command: |
            # Determine image tag
            if [ "$CIRCLE_BRANCH" = "main" ]; then
              IMAGE_TAG="latest"
            elif [ -n "$CIRCLE_TAG" ]; then
              IMAGE_TAG="$CIRCLE_TAG"
            else
              IMAGE_TAG="$CIRCLE_BRANCH"
            fi
            
            echo "export IMAGE_TAG=$IMAGE_TAG" >> $BASH_ENV
            
            FULL_IMAGE_NAME="driftmgr:$IMAGE_TAG"
            echo "export FULL_IMAGE_NAME=$FULL_IMAGE_NAME" >> $BASH_ENV
            
            # Build image
            docker build \
              --build-arg VERSION=$CIRCLE_BUILD_NUM \
              --build-arg COMMIT=$CIRCLE_SHA1 \
              --build-arg DATE=$(date -u '+%Y-%m-%d_%H:%M:%S') \
              -t $FULL_IMAGE_NAME \
              -f deployments/docker/Dockerfile .
      - run:
          name: Security scan Docker image
          command: |
            mkdir -p reports
            
            # Install Trivy
            wget -q https://github.com/aquasecurity/trivy/releases/download/v0.45.0/trivy_0.45.0_Linux-64bit.tar.gz
            tar zxf trivy_0.45.0_Linux-64bit.tar.gz
            sudo mv trivy /usr/local/bin/
            
            # Scan image
            trivy image --format sarif --output reports/trivy-docker-report.sarif $FULL_IMAGE_NAME
      - store_artifacts:
          path: reports
          destination: docker-security-reports
      - docker/push:
          image: driftmgr
          tag: $IMAGE_TAG
          registry: $DOCKER_REGISTRY
      - when:
          condition:
            or:
              - equal: [ main, << pipeline.git.branch >> ]
              - << pipeline.git.tag >>
          steps:
            - docker/push:
                image: driftmgr
                tag: $IMAGE_TAG
                registry: $DOCKER_REGISTRY

  # Drift detection
  drift_detection:
    docker:
      - image: cimg/go:1.23
    parameters:
      environment:
        type: string
        default: "staging"
      provider:
        type: string
        default: "all"
      force_scan:
        type: boolean
        default: false
    steps:
      - checkout
      - setup_environment
      - configure_cloud_providers
      - build_driftmgr
      - run_drift_detection:
          environment: << parameters.environment >>
          provider: << parameters.provider >>
          force_scan: << parameters.force_scan >>
      - run:
          name: Generate drift reports
          command: |
            if [ -f "reports/drift-report.json" ]; then
              # Generate HTML report
              ./driftmgr drift analyze \
                --input reports/drift-report.json \
                --output reports/drift-report.html \
                --format html \
                --include-recommendations
              
              # Generate CSV for analysis
              ./driftmgr drift export \
                --input reports/drift-report.json \
                --output reports/drift-export.csv \
                --format csv
            fi
      - store_artifacts:
          path: reports
          destination: drift-reports
      - run:
          name: Evaluate drift threshold
          command: |
            if [ "$DRIFT_DETECTED" = "true" ] && [ "$DRIFT_COUNT" -gt "${DRIFT_THRESHOLD:-10}" ]; then
              echo "Drift count ($DRIFT_COUNT) exceeds threshold (${DRIFT_THRESHOLD:-10})"
              exit 1
            fi

  # Automated remediation
  auto_remediation:
    docker:
      - image: cimg/go:1.23
    parameters:
      environment:
        type: string
      dry_run:
        type: boolean
        default: true
    steps:
      - checkout
      - setup_environment
      - configure_cloud_providers
      - build_driftmgr
      - attach_workspace:
          at: artifacts
      - run:
          name: Download drift reports
          command: |
            # This would download from previous job artifacts
            # For now, we'll assume reports are available
            mkdir -p reports
      - run:
          name: Generate remediation plan
          command: |
            ./driftmgr remediation plan \
              --drift-report reports/drift-report.json \
              --output reports/remediation-plan.json \
              --environment << parameters.environment >>
            
            # Generate impact analysis
            ./driftmgr remediation analyze \
              --plan reports/remediation-plan.json \
              --output reports/remediation-impact.json
      - run:
          name: Execute remediation
          command: |
            # Create backup
            ./driftmgr backup create \
              --environment << parameters.environment >> \
              --output reports/backup-$CIRCLE_BUILD_NUM.json
            
            # Execute remediation
            DRY_RUN_FLAG=""
            if [ "<< parameters.dry_run >>" = "true" ]; then
              DRY_RUN_FLAG="--dry-run"
            fi
            
            ./driftmgr remediation execute \
              $DRY_RUN_FLAG \
              --plan reports/remediation-plan.json \
              --output reports/remediation-result.json \
              --environment << parameters.environment >>
      - run:
          name: Verify remediation
          command: |
            # Wait for changes to propagate
            sleep 30
            
            # Re-run drift detection
            ./driftmgr drift detect \
              --provider all \
              --environment << parameters.environment >> \
              --output-format json \
              --output-file reports/post-remediation-report.json
            
            # Check remaining drift
            REMAINING_DRIFT=$(jq '.summary.total_drift_resources // 0' reports/post-remediation-report.json)
            if [ "$REMAINING_DRIFT" -gt 0 ]; then
              echo "[WARNING] $REMAINING_DRIFT resources still show drift after remediation"
            else
              echo "[OK] All drift successfully remediated"
            fi
      - store_artifacts:
          path: reports
          destination: remediation-reports

  # Release
  create_release:
    docker:
      - image: cimg/go:1.23
    steps:
      - checkout
      - attach_workspace:
          at: artifacts
      - run:
          name: Install GitHub CLI
          command: |
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt update
            sudo apt install gh
      - run:
          name: Create GitHub release
          command: |
            # Generate changelog
            git log --pretty=format:"- %s (%h)" $(git describe --tags --abbrev=0 HEAD^)..HEAD > CHANGELOG.md
            
            # Create release
            gh release create $CIRCLE_TAG \
              --title "Release $CIRCLE_TAG" \
              --notes-file CHANGELOG.md \
              artifacts/binaries/*.tar.gz \
              artifacts/binaries/*.zip

  # Deployment
  deploy:
    docker:
      - image: cimg/base:stable
    parameters:
      environment:
        type: string
    steps:
      - checkout
      - run:
          name: Install kubectl
          command: |
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
      - run:
          name: Deploy to << parameters.environment >>
          command: |
            # Configure kubectl (would use actual kubeconfig)
            echo "$KUBECONFIG_<< parameters.environment >>" | base64 -d > kubeconfig
            export KUBECONFIG=kubeconfig
            
            # Determine image tag
            if [ "$CIRCLE_BRANCH" = "main" ]; then
              IMAGE_TAG="latest"
            elif [ -n "$CIRCLE_TAG" ]; then
              IMAGE_TAG="$CIRCLE_TAG"
            else
              IMAGE_TAG="$CIRCLE_BRANCH"
            fi
            
            # Deploy
            kubectl set image deployment/driftmgr \
              driftmgr=$DOCKER_REGISTRY/driftmgr:$IMAGE_TAG \
              -n << parameters.environment >>
            
            kubectl rollout status deployment/driftmgr \
              -n << parameters.environment >> \
              --timeout=300s

# Workflows define the sequence of jobs
workflows:
  version: 2
  
  # Main CI/CD workflow
  main:
    jobs:
      # Setup
      - setup

      # Code quality (parallel)
      - lint_and_format:
          requires:
            - setup
      - security_scan:
          requires:
            - setup
      - license_check:
          requires:
            - setup

      # Testing (parallel)
      - unit_tests:
          requires:
            - lint_and_format
      - integration_tests:
          requires:
            - lint_and_format
      - benchmark_tests:
          requires:
            - lint_and_format

      # Build (parallel, after tests pass)
      - build_binaries:
          name: build-linux-amd64
          goos: linux
          goarch: amd64
          requires:
            - unit_tests
            - security_scan
      - build_binaries:
          name: build-linux-arm64
          goos: linux
          goarch: arm64
          requires:
            - unit_tests
            - security_scan
      - build_binaries:
          name: build-windows-amd64
          goos: windows
          goarch: amd64
          requires:
            - unit_tests
            - security_scan
      - build_binaries:
          name: build-darwin-amd64
          goos: darwin
          goarch: amd64
          requires:
            - unit_tests
            - security_scan
      - build_binaries:
          name: build-darwin-arm64
          goos: darwin
          goarch: arm64
          requires:
            - unit_tests
            - security_scan
      - build_docker:
          requires:
            - unit_tests
            - security_scan

      # Release (only on tags)
      - create_release:
          requires:
            - build-linux-amd64
            - build-linux-arm64
            - build-windows-amd64
            - build-darwin-amd64
            - build-darwin-arm64
            - build_docker
          filters:
            branches:
              ignore: /.*/
            tags:
              only: /^v.*/

      # Deploy to staging (only on main branch)
      - deploy:
          name: deploy-staging
          environment: staging
          requires:
            - build_docker
          filters:
            branches:
              only: main

      # Deploy to production (only on tags, with approval)
      - hold-production-deploy:
          type: approval
          requires:
            - create_release
          filters:
            branches:
              ignore: /.*/
            tags:
              only: /^v.*/
      - deploy:
          name: deploy-production
          environment: production
          requires:
            - hold-production-deploy
          filters:
            branches:
              ignore: /.*/
            tags:
              only: /^v.*/

  # Drift detection workflow (scheduled)
  drift_detection_scheduled:
    triggers:
      - schedule:
          cron: "0 6 * * *"  # Daily at 6 AM UTC
          filters:
            branches:
              only: main
    jobs:
      - setup
      - drift_detection:
          name: drift-check-production
          environment: production
          provider: all
          force_scan: false
          requires:
            - setup
      - drift_detection:
          name: drift-check-staging
          environment: staging
          provider: all
          force_scan: false
          requires:
            - setup
      - auto_remediation:
          name: auto-remediate-staging
          environment: staging
          dry_run: false
          requires:
            - drift-check-staging
          filters:
            branches:
              only: main
      # Production remediation requires manual approval
      - hold-production-remediation:
          type: approval
          requires:
            - drift-check-production
      - auto_remediation:
          name: auto-remediate-production
          environment: production
          dry_run: false
          requires:
            - hold-production-remediation

  # Manual drift detection workflow
  drift_detection_manual:
    when:
      and:
        - equal: [ webhook, << pipeline.trigger_source >> ]
        - equal: [ "drift-check", << pipeline.trigger_parameters.action >> ]
    jobs:
      - setup
      - drift_detection:
          environment: << pipeline.trigger_parameters.environment >>
          provider: << pipeline.trigger_parameters.provider >>
          force_scan: << pipeline.trigger_parameters.force_scan >>
          requires:
            - setup

# Slack notifications for important events
notify_slack: &notify_slack
  slack/notify:
    event: fail
    channel: '#infrastructure-alerts'
    template: basic_fail_1
    mentions: '@devops-team'

# Add notifications to critical jobs
workflows:
  main:
    jobs:
      # ... existing jobs ...
      - drift_detection:
          # ... existing config ...
          post-steps:
            - *notify_slack
      - auto_remediation:
          # ... existing config ...
          post-steps:
            - *notify_slack